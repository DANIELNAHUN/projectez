import { describe, it, expect, beforeEach, vi } from 'vitest'
import projectsModule from '../../store/modules/projects.js'
import { Project } from '../../models/index.js'

// Mock dependencies
vi.mock('../../services/storageService.js', () => ({
  storageService: {
    getProject: vi.fn(),
    saveProject: vi.fn(),
    getAllProjects: vi.fn(),
    deleteProject: vi.fn(),
    clearAllData: vi.fn()
  }
}))

vi.mock('../../composables/useErrorHandler.js', () => ({
  useErrorHandler: () => ({
    handleError: vi.fn(),
    handleStorageError: vi.fn(),
    handleValidationError: vi.fn()
  })
}))

vi.mock('../../services/notificationService.js', () => ({
  useNotifications: () => ({
    operationSuccess: vi.fn(),
    operationWarning: vi.fn()
  })
}))

vi.mock('../../services/openAIService.js', () => {
  const mockInstance = {
    initialize: vi.fn(),
    generateProject: vi.fn(),
    validateGeneratedProject: vi.fn()
  }
  return {
    OpenAIService: vi.fn().mockImplementation(() => mockInstance)
  }
})

vi.mock('../../services/projectExportService.js', () => ({
  ProjectExportService: {
    exportProject: vi.fn(),
    downloadJSON: vi.fn()
  }
}))

describe('Projects Store - AI Generation and Export', () => {
  let store
  let mockProject

  beforeEach(() => {
    // Reset store state
    store = {
      state: {
        projects: [],
        currentProject: null,
        loading: false,
        error: null
      },
      commit: vi.fn(),
      dispatch: vi.fn()
    }

    mockProject = new Project({
      id: 'project-1',
      name: 'Test Project',
      description: 'A test project',
      startDate: new Date('2024-01-15'),
      endDate: new Date('2024-02-15'),
      tasks: []
    })

    store.state.projects = [mockProject]
  })

  describe('exportProject action', () => {
    it('should successfully export a project', async () => {
      const { storageService } = await import('../../services/storageService.js')
      const { ProjectExportService } = await import('../../services/projectExportService.js')
      
      storageService.getProject.mockReturnValue(mockProject.toJSON())
      ProjectExportService.exportProject.mockReturnValue('{"name":"Test Project"}')
      ProjectExportService.downloadJSON.mockImplementation(() => {})

      const result = await projectsModule.actions.exportProject(store, 'project-1')

      expect(result.success).toBe(true)
      expect(result.filename).toContain('Test Project')
      expect(result.filename).toContain('.json')
      expect(store.commit).toHaveBeenCalledWith('SET_LOADING', true)
      expect(store.commit).toHaveBeenCalledWith('SET_LOADING', false)
      expect(ProjectExportService.exportProject).toHaveBeenCalledWith(mockProject.toJSON())
      expect(ProjectExportService.downloadJSON).toHaveBeenCalled()
    })

    it('should handle project not found', async () => {
      const { storageService } = await import('../../services/storageService.js')
      storageService.getProject.mockReturnValue(null)

      await expect(
        projectsModule.actions.exportProject(store, 'nonexistent')
      ).rejects.toThrow('Project with ID nonexistent not found')

      expect(store.commit).toHaveBeenCalledWith('SET_ERROR', 'Project with ID nonexistent not found')
    })

    it('should handle export service errors', async () => {
      const { storageService } = await import('../../services/storageService.js')
      const { ProjectExportService } = await import('../../services/projectExportService.js')
      
      storageService.getProject.mockReturnValue(mockProject.toJSON())
      ProjectExportService.exportProject.mockImplementation(() => {
        throw new Error('Export failed')
      })

      await expect(
        projectsModule.actions.exportProject(store, 'project-1')
      ).rejects.toThrow('Export failed')

      expect(store.commit).toHaveBeenCalledWith('SET_ERROR', 'Export failed')
    })
  })

  describe('generateProjectFromAI action', () => {
    it('should successfully generate a project from AI', async () => {
      const { OpenAIService } = await import('../../services/openAIService.js')
      
      const mockGeneratedProject = {
        name: 'AI Generated Project',
        description: 'Generated by AI',
        tasks: [
          {
            title: 'Task 1',
            description: 'First task',
            duration: 3
          }
        ]
      }

      // Mock the constructor to return our mock instance
      const mockAIService = {
        initialize: vi.fn().mockResolvedValue(),
        generateProject: vi.fn().mockResolvedValue(mockGeneratedProject),
        validateGeneratedProject: vi.fn().mockReturnValue({
          isValid: true,
          errors: [],
          warnings: []
        })
      }
      
      OpenAIService.mockImplementation(() => mockAIService)

      store.dispatch.mockResolvedValue(new Project(mockGeneratedProject))

      const result = await projectsModule.actions.generateProjectFromAI(store, {
        prompt: 'Create a web development project',
        apiKey: 'sk-test-key'
      })

      expect(result.success).toBe(true)
      expect(result.project).toBeDefined()
      expect(result.taskCount).toBe(1)
      expect(mockAIService.initialize).toHaveBeenCalledWith('sk-test-key')
      expect(mockAIService.generateProject).toHaveBeenCalledWith('Create a web development project')
      expect(store.dispatch).toHaveBeenCalledWith('importProject', mockGeneratedProject)
    })

    it('should handle missing prompt', async () => {
      await expect(
        projectsModule.actions.generateProjectFromAI(store, {
          prompt: '',
          apiKey: 'sk-test-key'
        })
      ).rejects.toThrow('Project prompt is required')

      expect(store.commit).toHaveBeenCalledWith('SET_ERROR', 'Project prompt is required')
    })

    it('should handle missing API key', async () => {
      await expect(
        projectsModule.actions.generateProjectFromAI(store, {
          prompt: 'Create a project',
          apiKey: ''
        })
      ).rejects.toThrow('OpenAI API key is required')

      expect(store.commit).toHaveBeenCalledWith('SET_ERROR', 'OpenAI API key is required')
    })

    it('should handle AI service initialization failure', async () => {
      const { OpenAIService } = await import('../../services/openAIService.js')
      
      const mockAIService = {
        initialize: vi.fn().mockRejectedValue(new Error('Invalid API key')),
        generateProject: vi.fn(),
        validateGeneratedProject: vi.fn()
      }
      
      OpenAIService.mockImplementation(() => mockAIService)

      await expect(
        projectsModule.actions.generateProjectFromAI(store, {
          prompt: 'Create a project',
          apiKey: 'invalid-key'
        })
      ).rejects.toThrow('Invalid API key')

      expect(store.commit).toHaveBeenCalledWith('SET_ERROR', 'Invalid API key')
    })

    it('should handle project generation failure', async () => {
      const { OpenAIService } = await import('../../services/openAIService.js')
      
      const mockAIService = {
        initialize: vi.fn().mockResolvedValue(),
        generateProject: vi.fn().mockRejectedValue(new Error('AI generation failed')),
        validateGeneratedProject: vi.fn()
      }
      
      OpenAIService.mockImplementation(() => mockAIService)

      await expect(
        projectsModule.actions.generateProjectFromAI(store, {
          prompt: 'Create a project',
          apiKey: 'sk-test-key'
        })
      ).rejects.toThrow('AI generation failed')

      expect(store.commit).toHaveBeenCalledWith('SET_ERROR', 'AI generation failed')
    })

    it('should handle validation failure', async () => {
      const { OpenAIService } = await import('../../services/openAIService.js')
      
      const mockGeneratedProject = { name: 'Invalid Project' }

      const mockAIService = {
        initialize: vi.fn().mockResolvedValue(),
        generateProject: vi.fn().mockResolvedValue(mockGeneratedProject),
        validateGeneratedProject: vi.fn().mockReturnValue({
          isValid: false,
          errors: ['Missing required fields'],
          warnings: []
        })
      }
      
      OpenAIService.mockImplementation(() => mockAIService)

      await expect(
        projectsModule.actions.generateProjectFromAI(store, {
          prompt: 'Create a project',
          apiKey: 'sk-test-key'
        })
      ).rejects.toThrow('Generated project validation failed: Missing required fields')

      expect(store.commit).toHaveBeenCalledWith('SET_ERROR', 'Generated project validation failed: Missing required fields')
    })
  })

  describe('validateAIProjectGeneration action', () => {
    it('should validate successful AI project generation inputs', async () => {
      const result = await projectsModule.actions.validateAIProjectGeneration(store, {
        prompt: 'Create a comprehensive web development project with authentication',
        apiKey: 'sk-test-key-123'
      })

      expect(result.isValid).toBe(true)
      expect(result.errors).toHaveLength(0)
      expect(result.warnings).toHaveLength(0)
      expect(result.promptLength).toBe(66)
      expect(result.estimatedTokens).toBeGreaterThan(0)
    })

    it('should return validation errors for missing prompt', async () => {
      const result = await projectsModule.actions.validateAIProjectGeneration(store, {
        prompt: '',
        apiKey: 'sk-test-key'
      })

      expect(result.isValid).toBe(false)
      expect(result.errors).toContain('Project prompt is required')
    })

    it('should return validation errors for missing API key', async () => {
      const result = await projectsModule.actions.validateAIProjectGeneration(store, {
        prompt: 'Create a project',
        apiKey: ''
      })

      expect(result.isValid).toBe(false)
      expect(result.errors).toContain('OpenAI API key is required')
    })

    it('should return warnings for short prompt', async () => {
      const result = await projectsModule.actions.validateAIProjectGeneration(store, {
        prompt: 'Short',
        apiKey: 'sk-test-key'
      })

      expect(result.isValid).toBe(true)
      expect(result.warnings).toContain('Very short prompts may generate basic projects')
    })

    it('should return warnings for long prompt', async () => {
      const longPrompt = 'A'.repeat(2001)
      const result = await projectsModule.actions.validateAIProjectGeneration(store, {
        prompt: longPrompt,
        apiKey: 'sk-test-key'
      })

      expect(result.isValid).toBe(true)
      expect(result.warnings).toContain('Very long prompts may be truncated by the AI service')
    })

    it('should return warnings for invalid API key format', async () => {
      const result = await projectsModule.actions.validateAIProjectGeneration(store, {
        prompt: 'Create a project',
        apiKey: 'invalid-key-format'
      })

      expect(result.isValid).toBe(true)
      expect(result.warnings).toContain('API key format may be invalid (should start with "sk-")')
    })

    it('should return warnings for problematic content', async () => {
      const result = await projectsModule.actions.validateAIProjectGeneration(store, {
        prompt: 'Create a project to hack systems',
        apiKey: 'sk-test-key'
      })

      expect(result.isValid).toBe(true)
      expect(result.warnings).toContain('Prompt contains potentially problematic words: hack')
    })

    it('should handle validation errors', async () => {
      // Mock an error in the validation process
      store.commit.mockImplementation((mutation, payload) => {
        if (mutation === 'SET_ERROR') {
          // Simulate error handling
        }
      })

      const result = await projectsModule.actions.validateAIProjectGeneration(store, {
        prompt: null, // This should cause an error
        apiKey: 'sk-test-key'
      })

      expect(result.isValid).toBe(false)
      expect(result.errors.length).toBeGreaterThan(0)
    })
  })

  describe('date calculation getters', () => {
    it('should calculate working days between dates', () => {
      const getWorkingDaysBetween = projectsModule.getters.getWorkingDaysBetween()
      const startDate = new Date('2024-01-15') // Monday
      const endDate = new Date('2024-01-19') // Friday
      
      const result = getWorkingDaysBetween(startDate, endDate)
      expect(result).toBeGreaterThanOrEqual(0)
    })

    it('should add working days to date', () => {
      const addWorkingDaysToDate = projectsModule.getters.addWorkingDaysToDate()
      const startDate = new Date('2024-01-15') // Monday
      const days = 5
      
      const result = addWorkingDaysToDate(startDate, days)
      expect(result).toBeInstanceOf(Date)
      expect(result.getTime()).toBeGreaterThan(startDate.getTime())
    })

    it('should check if date is working day', () => {
      // Mock the DateCalculationService for this test
      vi.doMock('../../services/dateCalculationService.js', () => ({
        DateCalculationService: {
          isWorkingDay: vi.fn((date) => {
            const day = date.getDay()
            return day !== 0 // Sunday is 0, so working days are 1-6
          })
        }
      }))
      
      const isWorkingDay = projectsModule.getters.isWorkingDay()
      const monday = new Date('2024-01-15') // Monday
      const sunday = new Date('2024-01-14') // Sunday
      
      expect(isWorkingDay(monday)).toBe(true)
      expect(isWorkingDay(sunday)).toBe(false)
    })

    it('should validate date range', () => {
      const validateDateRange = projectsModule.getters.validateDateRange()
      const startDate = new Date('2024-01-15')
      const endDate = new Date('2024-01-19')
      const invalidEndDate = new Date('2024-01-10')
      
      expect(validateDateRange(startDate, endDate)).toBe(true)
      expect(validateDateRange(startDate, invalidEndDate)).toBe(false)
    })

    it('should handle errors in date calculation getters', () => {
      // Mock require to throw an error
      const originalRequire = global.require
      global.require = vi.fn(() => {
        throw new Error('Service not available')
      })

      const getWorkingDaysBetween = projectsModule.getters.getWorkingDaysBetween()
      const result = getWorkingDaysBetween(new Date(), new Date())
      
      expect(result).toBe(0) // Should return default value on error
      
      // Restore original require
      global.require = originalRequire
    })
  })
})