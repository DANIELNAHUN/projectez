import { describe, it, expect, beforeEach, vi } from 'vitest'
import projectsModule from '../../store/modules/projects.js'
import { Project, Task } from '../../models/index.js'

// Mock dependencies
vi.mock('../../services/storageService.js', () => ({
  storageService: {
    getProject: vi.fn(),
    saveProject: vi.fn(),
    getAllProjects: vi.fn(),
    deleteProject: vi.fn(),
    clearAllData: vi.fn()
  }
}))

vi.mock('../../composables/useErrorHandler.js', () => ({
  useErrorHandler: () => ({
    handleError: vi.fn(),
    handleStorageError: vi.fn(),
    handleValidationError: vi.fn()
  })
}))

vi.mock('../../services/notificationService.js', () => ({
  useNotifications: () => ({
    operationSuccess: vi.fn(),
    operationWarning: vi.fn()
  })
}))

vi.mock('../../services/projectImportService.js', () => ({
  ProjectImportService: {
    prepareProjectForImport: vi.fn(),
    importProject: vi.fn(),
    generateUniqueProjectId: vi.fn()
  }
}))

vi.mock('../../services/dateCalculationService.js', () => ({
  DateCalculationService: {
    addWorkingDays: vi.fn(),
    subtractWorkingDays: vi.fn(),
    calculateWorkingDays: vi.fn(),
    validateDateRange: vi.fn()
  }
}))

describe('Projects Store - Import/Export', () => {
  let store
  let mockProject

  beforeEach(() => {
    // Reset store state
    store = {
      state: {
        projects: [],
        currentProject: null,
        loading: false,
        error: null
      },
      commit: vi.fn(),
      dispatch: vi.fn()
    }

    mockProject = new Project({
      id: 'project-1',
      name: 'Test Project',
      description: 'A test project',
      startDate: new Date('2024-01-15'),
      endDate: new Date('2024-02-15'),
      tasks: []
    })

    store.state.projects = [mockProject]
  })

  describe('importProject action', () => {
    it('should successfully import project from JSON string', async () => {
      const { storageService } = await import('../../services/storageService.js')
      const { ProjectImportService } = await import('../../services/projectImportService.js')
      
      const jsonData = JSON.stringify({
        id: 'imported-project',
        name: 'Imported Project',
        description: 'Imported from JSON',
        tasks: []
      })

      const preparedProject = new Project({
        id: 'imported-project-unique',
        name: 'Imported Project',
        description: 'Imported from JSON',
        tasks: []
      })

      ProjectImportService.prepareProjectForImport.mockReturnValue(jsonData)
      ProjectImportService.importProject.mockReturnValue(preparedProject)
      storageService.saveProject.mockResolvedValue()

      const result = await projectsModule.actions.importProject(store, jsonData)

      expect(result).toBeInstanceOf(Project)
      expect(store.commit).toHaveBeenCalledWith('SET_LOADING', true)
      expect(store.commit).toHaveBeenCalledWith('SET_LOADING', false)
      expect(store.commit).toHaveBeenCalledWith('ADD_PROJECT', preparedProject)
      expect(storageService.saveProject).toHaveBeenCalledWith(preparedProject)
    })

    it('should successfully import project from object (AI generated)', async () => {
      const { storageService } = await import('../../services/storageService.js')
      const { DateCalculationService } = await import('../../services/dateCalculationService.js')
      
      const projectData = {
        id: 'ai-project',
        name: 'AI Generated Project',
        description: 'Generated by AI',
        startDate: new Date('2024-01-15'),
        tasks: [
          {
            id: 'task-1',
            title: 'Task 1',
            description: 'First task',
            duration: 3,
            startDate: new Date('2024-01-15')
          },
          {
            id: 'task-2',
            title: 'Task 2',
            description: 'Second task',
            duration: 5,
            subtasks: [
              {
                id: 'subtask-1',
                title: 'Subtask 1',
                duration: 2
              }
            ]
          }
        ]
      }

      storageService.saveProject.mockResolvedValue()
      DateCalculationService.addWorkingDays.mockImplementation((date, days) => {
        const result = new Date(date)
        result.setDate(result.getDate() + days)
        return result
      })

      const result = await projectsModule.actions.importProject(store, projectData)

      expect(result).toBeInstanceOf(Project)
      expect(result.name).toBe('AI Generated Project')
      expect(result.tasks).toHaveLength(2)
      expect(result.tasks[1].subtasks).toHaveLength(1)
      expect(store.commit).toHaveBeenCalledWith('ADD_PROJECT', expect.any(Project))
    })

    it('should handle duplicate project IDs', async () => {
      const { storageService } = await import('../../services/storageService.js')
      const { ProjectImportService } = await import('../../services/projectImportService.js')
      
      const projectData = {
        id: 'project-1', // Same as existing project
        name: 'Duplicate Project',
        tasks: []
      }

      ProjectImportService.generateUniqueProjectId.mockReturnValue('project-1-unique')
      storageService.saveProject.mockResolvedValue()

      const result = await projectsModule.actions.importProject(store, projectData)

      expect(result.id).toBe('project-1-unique')
      expect(ProjectImportService.generateUniqueProjectId).toHaveBeenCalledWith(
        'project-1',
        ['project-1']
      )
    })

    it('should handle tasks with invalid dates', async () => {
      const { storageService } = await import('../../services/storageService.js')
      const { DateCalculationService } = await import('../../services/dateCalculationService.js')
      
      const projectData = {
        id: 'project-invalid-dates',
        name: 'Project with Invalid Dates',
        tasks: [
          {
            id: 'task-invalid',
            title: 'Task with Invalid Date',
            startDate: 'invalid-date',
            duration: 3
          }
        ]
      }

      storageService.saveProject.mockResolvedValue()
      DateCalculationService.addWorkingDays.mockImplementation((date, days) => {
        const result = new Date(date)
        result.setDate(result.getDate() + days)
        return result
      })

      const result = await projectsModule.actions.importProject(store, projectData)

      expect(result).toBeInstanceOf(Project)
      expect(result.tasks).toHaveLength(1)
      // Task should have valid dates assigned during processing
      expect(result.tasks[0].startDate).toBeInstanceOf(Date)
      expect(result.tasks[0].endDate).toBeInstanceOf(Date)
    })

    it('should handle project date adjustment during import', async () => {
      const { storageService } = await import('../../services/storageService.js')
      const { DateCalculationService } = await import('../../services/dateCalculationService.js')
      
      const projectData = {
        id: 'project-adjust-dates',
        name: 'Project with Date Adjustment',
        startDate: new Date('2024-02-01'), // Different from task dates
        tasks: [
          {
            id: 'task-1',
            title: 'Task 1',
            startDate: new Date('2024-01-15'),
            duration: 3
          }
        ]
      }

      storageService.saveProject.mockResolvedValue()
      DateCalculationService.addWorkingDays.mockImplementation((date, days) => {
        const result = new Date(date)
        result.setDate(result.getDate() + days)
        return result
      })

      // Mock the adjustProjectDates method
      const mockAdjustProjectDates = vi.fn()
      vi.doMock('../../models/index.js', async () => {
        const actual = await vi.importActual('../../models/index.js')
        return {
          ...actual,
          Project: class extends actual.Project {
            adjustProjectDates = mockAdjustProjectDates
          }
        }
      })

      const result = await projectsModule.actions.importProject(store, projectData)

      expect(result).toBeInstanceOf(Project)
      // Should attempt to adjust dates if start date is different
    })

    it('should handle import validation errors', async () => {
      const invalidProjectData = {
        // Missing required fields
        name: 'Invalid Project'
      }

      await expect(
        projectsModule.actions.importProject(store, invalidProjectData)
      ).rejects.toThrow()

      expect(store.commit).toHaveBeenCalledWith('SET_ERROR', expect.any(String))
    })

    it('should handle storage errors during import', async () => {
      const { storageService } = await import('../../services/storageService.js')
      
      const projectData = {
        id: 'project-storage-error',
        name: 'Project Storage Error',
        tasks: []
      }

      storageService.saveProject.mockRejectedValue(new Error('Storage quota exceeded'))

      await expect(
        projectsModule.actions.importProject(store, projectData)
      ).rejects.toThrow('Storage quota exceeded')

      expect(store.commit).toHaveBeenCalledWith('SET_ERROR', 'Storage quota exceeded')
    })

    it('should handle task processing errors gracefully', async () => {
      const { storageService } = await import('../../services/storageService.js')
      const { DateCalculationService } = await import('../../services/dateCalculationService.js')
      
      const projectData = {
        id: 'project-task-errors',
        name: 'Project with Task Errors',
        tasks: [
          {
            id: 'valid-task',
            title: 'Valid Task',
            duration: 3
          },
          {
            // Task that will cause processing error
            title: null, // Invalid title
            duration: 'invalid'
          },
          {
            id: 'another-valid-task',
            title: 'Another Valid Task',
            duration: 2
          }
        ]
      }

      storageService.saveProject.mockResolvedValue()
      DateCalculationService.addWorkingDays.mockImplementation((date, days) => {
        const result = new Date(date)
        result.setDate(result.getDate() + days)
        return result
      })

      const result = await projectsModule.actions.importProject(store, projectData)

      expect(result).toBeInstanceOf(Project)
      // Should continue processing even if some tasks fail
      expect(result.tasks.length).toBeGreaterThan(0)
    })

    it('should handle nested subtasks correctly', async () => {
      const { storageService } = await import('../../services/storageService.js')
      const { DateCalculationService } = await import('../../services/dateCalculationService.js')
      
      const projectData = {
        id: 'project-nested-tasks',
        name: 'Project with Nested Tasks',
        tasks: [
          {
            id: 'parent-task',
            title: 'Parent Task',
            duration: 10,
            subtasks: [
              {
                id: 'child-task-1',
                title: 'Child Task 1',
                duration: 3,
                subtasks: [
                  {
                    id: 'grandchild-task',
                    title: 'Grandchild Task',
                    duration: 1
                  }
                ]
              },
              {
                id: 'child-task-2',
                title: 'Child Task 2',
                duration: 5
              }
            ]
          }
        ]
      }

      storageService.saveProject.mockResolvedValue()
      DateCalculationService.addWorkingDays.mockImplementation((date, days) => {
        const result = new Date(date)
        result.setDate(result.getDate() + days)
        return result
      })

      const result = await projectsModule.actions.importProject(store, projectData)

      expect(result).toBeInstanceOf(Project)
      expect(result.tasks).toHaveLength(1)
      expect(result.tasks[0].subtasks).toHaveLength(2)
      expect(result.tasks[0].subtasks[0].subtasks).toHaveLength(1)
    })

    it('should set project end date based on last task', async () => {
      const { storageService } = await import('../../services/storageService.js')
      const { DateCalculationService } = await import('../../services/dateCalculationService.js')
      
      const projectData = {
        id: 'project-end-date',
        name: 'Project End Date Test',
        tasks: [
          {
            id: 'task-1',
            title: 'Task 1',
            duration: 3
          },
          {
            id: 'task-2',
            title: 'Task 2',
            duration: 5
          }
        ]
      }

      const lastTaskEndDate = new Date('2024-02-15')
      storageService.saveProject.mockResolvedValue()
      DateCalculationService.addWorkingDays.mockImplementation((date, days) => {
        if (days === 5) return lastTaskEndDate // For the last task
        const result = new Date(date)
        result.setDate(result.getDate() + days)
        return result
      })

      const result = await projectsModule.actions.importProject(store, projectData)

      expect(result.endDate).toEqual(lastTaskEndDate)
    })
  })

  describe('clearAllProjects action', () => {
    it('should successfully clear all projects', async () => {
      const { storageService } = await import('../../services/storageService.js')
      
      storageService.clearAllData.mockResolvedValue()

      const result = await projectsModule.actions.clearAllProjects(store)

      expect(result).toBe(true)
      expect(store.commit).toHaveBeenCalledWith('SET_PROJECTS', [])
      expect(store.commit).toHaveBeenCalledWith('SET_CURRENT_PROJECT', null)
      expect(storageService.clearAllData).toHaveBeenCalled()
    })

    it('should handle storage errors during clear', async () => {
      const { storageService } = await import('../../services/storageService.js')
      
      storageService.clearAllData.mockRejectedValue(new Error('Clear failed'))

      await expect(
        projectsModule.actions.clearAllProjects(store)
      ).rejects.toThrow('Clear failed')

      expect(store.commit).toHaveBeenCalledWith('SET_ERROR', 'Clear failed')
    })
  })

  describe('import edge cases', () => {
    it('should handle empty tasks array', async () => {
      const { storageService } = await import('../../services/storageService.js')
      
      const projectData = {
        id: 'project-empty-tasks',
        name: 'Project with Empty Tasks',
        tasks: []
      }

      storageService.saveProject.mockResolvedValue()

      const result = await projectsModule.actions.importProject(store, projectData)

      expect(result).toBeInstanceOf(Project)
      expect(result.tasks).toHaveLength(0)
    })

    it('should handle missing tasks property', async () => {
      const { storageService } = await import('../../services/storageService.js')
      
      const projectData = {
        id: 'project-no-tasks',
        name: 'Project without Tasks Property'
        // No tasks property
      }

      storageService.saveProject.mockResolvedValue()

      const result = await projectsModule.actions.importProject(store, projectData)

      expect(result).toBeInstanceOf(Project)
      expect(result.tasks).toHaveLength(0)
    })

    it('should handle tasks with missing duration', async () => {
      const { storageService } = await import('../../services/storageService.js')
      const { DateCalculationService } = await import('../../services/dateCalculationService.js')
      
      const projectData = {
        id: 'project-no-duration',
        name: 'Project with Tasks Missing Duration',
        tasks: [
          {
            id: 'task-no-duration',
            title: 'Task without Duration'
            // No duration property
          }
        ]
      }

      storageService.saveProject.mockResolvedValue()
      DateCalculationService.addWorkingDays.mockImplementation((date, days) => {
        const result = new Date(date)
        result.setDate(result.getDate() + (days || 1)) // Default to 1 day
        return result
      })

      const result = await projectsModule.actions.importProject(store, projectData)

      expect(result).toBeInstanceOf(Project)
      expect(result.tasks).toHaveLength(1)
      expect(result.tasks[0].duration).toBe(1) // Should default to 1
    })
  })
})